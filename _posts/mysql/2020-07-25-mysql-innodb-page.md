---
layout: post
title: MySQL InnoDB数据页结构(Page Structure)
categories: MySQL
description: MySQL InnoDB数据页结构
keywords: MySQL, Database, 数据库
---

`页`是`InnoDB`管理存储空间的基本单位，一般一个页的大小是`16KB`。`InnoDB`为了实现不同的目的而设计了许多页，比如存放表空间头部信息的页，存放`Insert Buffer`信息的页等等。存放我们表中记录的页是`索引页（index page）`，鉴于我们还没有了解过索引是个什么东西，而这些表中的记录就是我们日常口中所称的`数据`，所以目前还是叫这种存放记录的页为`数据页`吧。

# 1. 数据页结构的快速浏览

数据页代表的这块`16KB`大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

![mysql10](/images/posts/mysql/mysql_10.PNG)

从图中可以看出，一个`InnoDB`数据页的存储空间大致被划分成了`7`个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。

<br/>

# 2. 记录在页中的存储

在上图的7个部分中，`User Records`部分是存储记录的。其实，一开始是没有`User Records`这部分的，每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。

![mysql11](/images/posts/mysql/mysql_11.png)

`InnoDB`管理`User Records`是很复杂的过程，并不是把记录直接放在`User Records`部分就完成了。我们先从记录头信息来理解这个过程。

## 2.1 记录头信息

先建一个表：

```sql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
```

这个新创建的`page_demo`表有3个列，其中`c1`和`c2`列是用来存储整数的，`c3`列是用来存储字符串的。需要注意的是，我们把 ***c1*** 列指定为主键，所以在具体的行格式中`InnoDB`就没必要为我们去创建那个所谓的 ***row_id*** 隐藏列了。而且我们为这个表指定了`ascii`字符集以及`Compact`的行格式。所以这个表中记录的行格式示意图就是这样的：

![mysql12](/images/posts/mysql/mysql_12.png)

记录头中的属性如下：

|      名称      | 大小（单位：bit） |                             描述                             |
| :------------: | :---------------: | :----------------------------------------------------------: |
|   `预留位1`    |        `1`        |                           没有使用                           |
|   `预留位2`    |        `1`        |                           没有使用                           |
| `delete_mask`  |        `1`        |                     标记该记录是否被删除                     |
| `min_rec_mask` |        `1`        |        B+树的每层非叶子节点中的最小记录都会添加该标记        |
|   `n_owned`    |        `4`        |                   表示当前记录拥有的记录数                   |
|   `heap_no`    |       `13`        |                表示当前记录在记录堆的位置信息                |
| `record_type`  |        `3`        | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  |       `16`        |                   表示下一条记录的相对位置                   |

![mysql13](/images/posts/mysql/mysql_13.png)

我们向`page_demo`表中插入几条记录：

```sql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
```

为了方便大家分析这些记录在`页`的`User Records`部分中是怎么表示的，我把记录中头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：

![mysql14](/images/posts/mysql/mysql_14.png)

- `delete_mask`

  这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的`垃圾链表`，在这个链表中的记录占用的空间称之为所谓的`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- `min_rec_mask`

  B+树的每层非叶子节点中的最小记录都会添加该标记。

- `n_owned`

  稍后介绍

- `heap_no`

  这个属性表示当前记录在本`页`中的位置，从图中可以看出来，我们插入的4条记录在本`页`中的位置分别是：`2`、`3`、`4`、`5`。`0`和`1`的记录并不是我们自己插入的，所以有时候也称为`伪记录`或者`虚拟记录`。这两个伪记录一个代表`最小记录`，一个代表`最大记录`。

  实际上，记录也是可以比较大小的，对于一条完整的记录来说，比较记录的大小就是比较`主键`的大小。比方说我们插入的4行记录的主键值分别是：`1`、`2`、`3`、`4`，这也就意味着这4条记录的大小从小到大依次递增。

但是不管我们向`页`中插入了多少自己的记录，`InnoDB`都规定两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的`记录头信息`和8字节大小的一个固定的部分组成的。

由于这两条记录不是我们自己定义的记录，所以它们并不存放在`页`的`User Records`部分，他们被单独放在一个称为`Infimum + Supremum`的部分，如图所示：

![mysql15](/images/posts/mysql/mysql_15.png)

- `record_type`

  这个属性表示当前记录的类型，一共有4种类型的记录，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录。

- `next_record`

<br/>

------

**参考文章：**